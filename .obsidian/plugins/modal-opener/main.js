/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ModalOpenerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/modal.ts
var import_obsidian2 = require("obsidian");

// src/lang/helpers.ts
var import_obsidian = require("obsidian");

// src/lang/locale/ar.ts
var ar_default = {};

// src/lang/locale/cz.ts
var cz_default = {};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {};

// src/lang/locale/en.ts
var en_default = {
  "No active modal window": "No active modal window",
  "No link found at cursor position": "No link found at cursor position",
  "Create and edit in modal": "Create and edit in modal",
  "Enter new file name": "Enter new file name: ",
  "Wiki link": "Wiki link",
  "Embed link": "Embed link",
  "Unsupported file or link format": "Unsupported file or link format",
  "Drag duration too short": "Drag duration too short",
  "The file or link does not exist: ": "The file or link does not exist: ",
  "Failed to create file: ": "Failed to create file: ",
  "Open in modal window error": "Open in modal window error",
  "Open in modal window": "Open in modal window",
  "Delete linked attachment": "Delete linked attachment",
  "Confirm deletion": "Confirm deletion",
  "Are you sure you want to delete: ": "Are you sure you want to delete: ",
  "File moved to trash": "File moved to trash",
  "Failed to delete file": "Failed to delete file",
  // General settings
  "Open with": "Open with",
  "Drag & Drop": "Drag & Drop",
  // 'Middle mouse button':'Middle mouse button(Only reading view)',
  "Alt & Left click": "Alt & Left click",
  "Both": "Both",
  "Default editing mode": "Default editing mode",
  "Select the default mode for opening files in the modal window": "Select the default mode for opening files in the modal window",
  "Current file": "Current file",
  "Reading": "Reading",
  "Editing": "Editing",
  "Drag and drop time threshold": "Drag and drop time threshold",
  "Set the minimum drag and drop time (in milliseconds) to trigger the link to open.": "Set the minimum drag and drop time (in milliseconds) to trigger the link to open",
  "Add hover button": "Add hover button",
  "Add hover button to": "Add hover button to",
  "Add hover button for accessibility functions in the modal window": "Add hover button for accessibility functions in the modal window",
  "File view": "File view",
  "Link view": "Link view",
  "Opens in new tab": "Opens in new tab",
  "Open in browser": "Open in browser",
  "Copy web link": "Copy web link",
  "Switch dark mode": "Switch dark mode",
  "More options": "More options",
  "Copied to clipboard": "Link copied to clipboard",
  "Behavior": "Behavior",
  "Disable external click close": "Disable external click close",
  'Use only the "Close" button and "Esc" to close.': 'Use only the "Close" button and "Esc" to close',
  "Refresh view on close": "Refresh view on close",
  "Refresh views when closing modal window, currently only refreshing after editing Canvas and Markmind file": "Refresh views when closing modal, currently only refreshing after editing Canvas and Markmind file",
  "Prevents duplicate tabs": "Prevents duplicate tabs",
  "In a new leaf opened the note to prevent duplicate (compatible with Modal-Opener, function from Mononote plugin)": "In a new leaf opened the note to prevent duplicate (compatible with Modal-Opener, function from Mononote plugin",
  "Delay time": "Delay time",
  "Delay in milliseconds before performing operations": "Delay in milliseconds before performing operations",
  "Styles": "Styles",
  "Modal width": "Modal width",
  "Modal height": "Modal height",
  "Enter any valid CSS unit": "Enter any valid CSS unit",
  "Enable animation and blur": "Enable animation and blur",
  "Toggle to enable or disable animation and blur effects": "Toggle to enable or disable animation and blur effects",
  "Show view header of the file": "Show view header of the file",
  "Show view header of the link": "Show view header of the link",
  "Show the view header of the file in the modal window": "Show the view header of the file in the modal window",
  "Show the Surfing plugin's navigation bar and bookmarks bar": "Show the Surfing plugin's navigation bar and bookmarks bar in the modal window",
  "Show metadata": "Display metadata",
  "Show file metadata in the modal window": "Show file metadata in the modal window",
  "Hide tab header": "Hide tab header",
  "Hides the tab header associated with the modal window": "Hides the tab header associated with the modal window",
  "Custom commands": "Custom commands",
  "Add custom command": "Add custom command",
  "Add a new custom command": "Commands can be used with other plugins, such as Commander",
  "Add": "Add",
  "Command name": "Input the command name",
  "Command": "Command",
  "Description": "Enter file path or web link",
  "Delete": "Delete",
  "Confirm": "Confirm",
  "Cancel": "Cancel",
  "The command name already exists, please use a different name": "The command name already exists, please use a different name",
  "Command added successfully": "Command added successfully",
  "Please enter both command name and description": "Please enter both command name and description",
  "Command deleted successfully. Please restart Obsidian for changes to take full effect.": "Command deleted successfully. Please restart Obsidian for changes to take full effect."
};

// src/lang/locale/en-gb.ts
var en_gb_default = {};

// src/lang/locale/es.ts
var es_default = {};

// src/lang/locale/fr.ts
var fr_default = {};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {};

// src/lang/locale/ja.ts
var ja_default = {};

// src/lang/locale/ko.ts
var ko_default = {};

// src/lang/locale/nl.ts
var nl_default = {};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {};

// src/lang/locale/tr.ts
var tr_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {
  "No active modal window": "\u6CA1\u6709\u6D3B\u52A8\u7684\u6A21\u6001\u7A97\u53E3",
  "No link found at cursor position": "\u5728\u5149\u6807\u4F4D\u7F6E\u627E\u4E0D\u5230\u94FE\u63A5",
  "Create and edit in modal": "\u521B\u5EFA\u5E76\u5728\u6A21\u6001\u7A97\u53E3\u4E2D\u7F16\u8F91",
  "Enter new file name": "\u8F93\u5165\u65B0\u6587\u4EF6\u540D\uFF1A",
  "Wiki link": "Wiki\u94FE\u63A5",
  "Embed link": "\u5D4C\u5165\u94FE\u63A5",
  "Unsupported file or link format": "\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u6216\u94FE\u63A5\u683C\u5F0F",
  "Drag duration too short": "\u62D6\u62FD\u65F6\u95F4\u592A\u77ED",
  "The file or link does not exist: ": "\u6587\u4EF6\u6216\u94FE\u63A5\u4E0D\u5B58\u5728: ",
  "Failed to create file: ": "\u521B\u5EFA\u6587\u4EF6\u5931\u8D25: ",
  "Open in modal window error": "\u5728\u6A21\u6001\u7A97\u53E3\u4E2D\u6253\u5F00\u9519\u8BEF",
  "Open in modal window": "\u5728\u6A21\u6001\u7A97\u53E3\u4E2D\u6253\u5F00",
  "Delete linked attachment": "\u5220\u9664\u94FE\u63A5\u9644\u4EF6",
  "Confirm deletion": "\u786E\u8BA4\u5220\u9664",
  "Are you sure you want to delete: ": "\u786E\u5B9A\u8981\u5220\u9664\uFF1F",
  "File moved to trash": "\u6587\u4EF6\u79FB\u81F3\u5E9F\u7EB8\u7BD3",
  "Failed to delete file": "\u5220\u9664\u6587\u4EF6\u5931\u8D25",
  // General settings
  "Open with": "\u6253\u5F00\u65B9\u5F0F",
  "Drag & Drop": "\u62D6\u62FD",
  // 'Middle mouse button':'鼠标中键（仅阅读视图）',
  "Alt & Left click": "Alt\uFF0B\u5DE6\u952E",
  "Both": "\u5168\u90E8",
  "Default editing mode": "\u9ED8\u8BA4\u7F16\u8F91\u6A21\u5F0F",
  "Select the default mode for opening files in the modal window": "\u9009\u62E9\u6253\u5F00\u6587\u4EF6\u7684\u9ED8\u8BA4\u6A21\u5F0F",
  "Current file": "\u5F53\u524D\u6587\u4EF6",
  "Reading": "\u9605\u8BFB\u6A21\u5F0F",
  "Editing": "\u7F16\u8F91\u6A21\u5F0F",
  "Drag and drop time threshold": "\u62D6\u62FD\u65F6\u95F4\u9608\u503C",
  "Set the minimum drag and drop time (in milliseconds) to trigger the link to open.": "\u8BBE\u7F6E\u89E6\u53D1\u94FE\u63A5\u6253\u5F00\u7684\u6700\u5C0F\u62D6\u653E\u65F6\u95F4\uFF08\u4EE5\u6BEB\u79D2\u4E3A\u5355\u4F4D\uFF09",
  "Add hover button": "\u6DFB\u52A0\u60AC\u6D6E\u6309\u94AE",
  "Add hover button to": "\u6DFB\u52A0\u60AC\u6D6E\u6309\u94AE\u7684\u89C6\u56FE",
  "Add hover button for accessibility functions in the modal window": "\u5728\u6A21\u6001\u7A97\u53E3\u4E2D\u6DFB\u52A0\u7528\u4E8E\u8F85\u52A9\u529F\u80FD\u7684\u60AC\u505C\u6309\u94AE",
  "File view": "\u6587\u4EF6\u89C6\u56FE",
  "Link view": "\u94FE\u63A5\u89C6\u56FE",
  "Opens in new tab": "\u5728\u65B0\u6807\u7B7E\u9875\u4E2D\u6253\u5F00",
  "Open in browser": "\u5728\u6D4F\u89C8\u5668\u6253\u5F00",
  "Copy web link": "\u590D\u5236\u7F51\u9875\u94FE\u63A5",
  "Switch dark mode": "\u5207\u6362\u591C\u95F4\u6A21\u5F0F",
  "More options": "\u66F4\u591A\u9009\u9879",
  "Copied to clipboard": "\u94FE\u63A5\u5DF2\u590D\u5236\u5230\u526A\u5207\u677F",
  "Behavior": "\u884C\u4E3A",
  "Disable external click close": "\u7981\u7528\u5916\u90E8\u70B9\u51FB\u5173\u95ED",
  'Use only the "Close" button and "Esc" to close.': "\u4EC5\u4F7F\u7528 \u201C\u5173\u95ED\u201D \u6309\u94AE\u548C Esc \u5173\u95ED",
  "Refresh view on close": "\u5173\u95ED\u540E\u5237\u65B0\u89C6\u56FE",
  "Refresh views when closing modal window, currently only refreshing after editing Canvas and Markmind file": "\u5173\u95ED\u6A21\u6001\u7A97\u53E3\u65F6\u5237\u65B0\u89C6\u56FE\uFF0C\u76EE\u524D\u4EC5\u5728\u7F16\u8F91Canvas\u548CMarkmind\u6587\u4EF6\u540E\u5237\u65B0",
  "Prevents duplicate tabs": "\u9632\u6B62\u91CD\u590D\u6807\u7B7E\u9875",
  "In a new leaf opened the note to prevent duplicate (compatible with Modal-Opener, function from Mononote plugin)": "\u9632\u6B62\u91CD\u590D\u6807\u7B7E\u9875\u6253\u5F00\u7B14\u8BB0\uFF08\u517C\u5BB9Modal-Opener\uFF0C\u529F\u80FD\u6765\u81EAMononote\u63D2\u4EF6\uFF09",
  "Delay time": "\u5EF6\u8FDF\u65F6\u95F4",
  "Delay in milliseconds before performing operations": "\u6267\u884C\u64CD\u4F5C\u4E4B\u524D\u7684\u5EF6\u8FDF(\u4EE5\u6BEB\u79D2\u4E3A\u5355\u4F4D)",
  "Styles": "\u6837\u5F0F",
  "Modal width": "\u7A97\u53E3\u5BBD\u5EA6",
  "Modal height": "\u7A97\u53E3\u9AD8\u5EA6",
  "Enter any valid CSS unit": "\u8F93\u5165\u4EFB\u4F55\u6709\u6548\u7684CSS\u5355\u4F4D",
  "Enable animation and blur": "\u542F\u7528\u52A8\u753B\u548C\u6A21\u7CCA",
  "Toggle to enable or disable animation and blur effects": "\u5207\u6362\u4EE5\u542F\u7528\u6216\u7981\u7528\u52A8\u753B\u548C\u6A21\u7CCA\u6548\u679C",
  "Show view header of the file": "\u663E\u793A\u6587\u4EF6\u7684\u89C6\u56FE\u6807\u9898",
  "Show view header of the link": "\u663E\u793A\u94FE\u63A5\u7684\u89C6\u56FE\u6807\u9898",
  "Show the view header of the file in the modal window": "\u5728\u6A21\u6001\u7A97\u53E3\u4E2D\u663E\u793A\u6587\u4EF6\u89C6\u56FE\u7684\u5934\u90E8\u6807\u9898",
  "Show the Surfing plugin's navigation bar and bookmarks bar": "\u5728\u6A21\u6001\u7A97\u53E3\u4E2D\u663E\u793ASurfing\u63D2\u4EF6\u7684\u5BFC\u822A\u680F\u548C\u4E66\u7B7E\u680F",
  "Show metadata": "\u663E\u793A\u5143\u6570\u636E",
  "Show file metadata in the modal window": "\u5728\u6A21\u6001\u7A97\u53E3\u4E2D\u663E\u793A\u6587\u4EF6\u5143\u6570\u636E",
  "Hide tab header": "\u9690\u85CF\u6807\u7B7E\u9875\u5934\u90E8",
  "Hides the tab header associated with the modal window": "\u9690\u85CF\u4E0E\u6A21\u6001\u7A97\u53E3\u5173\u8054\u7684\u6807\u7B7E\u9875\u5934\u90E8",
  "Custom commands": "\u81EA\u5B9A\u4E49\u547D\u4EE4",
  "Add custom command": "\u6DFB\u52A0\u81EA\u5B9A\u4E49\u547D\u4EE4",
  "Add a new custom command": "\u547D\u4EE4\u53EF\u4EE5\u4E0E\u5176\u4ED6\u63D2\u4EF6\u642D\u914D\u4F7F\u7528\uFF0C\u4F8B\u5982 Commander",
  "Add": "\u6DFB\u52A0",
  "Command name": "\u8F93\u5165\u547D\u4EE4\u540D\u79F0",
  "Command": "\u547D\u4EE4",
  "Description": "\u8F93\u5165\u6587\u4EF6\u8DEF\u5F84\u6216\u7F51\u9875\u94FE\u63A5",
  "Delete": "\u5220\u9664",
  "Confirm": "\u786E\u8BA4",
  "Cancel": "\u53D6\u6D88",
  "The command name already exists, please use a different name": "\u547D\u4EE4\u540D\u79F0\u5DF2\u5B58\u5728\uFF0C\u8BF7\u4F7F\u7528\u4E0D\u540C\u7684\u540D\u79F0",
  "Command added successfully": "\u547D\u4EE4\u6DFB\u52A0\u6210\u529F",
  "Please enter both command name and description": "\u8BF7\u8F93\u5165\u547D\u4EE4\u540D\u79F0\u548C\u63CF\u8FF0",
  "Command deleted successfully. Please restart Obsidian for changes to take full effect.": "\u547D\u4EE4\u5220\u9664\u6210\u529F\uFF0C\u8BF7\u91CD\u65B0\u542F\u52A8 Obsidian \u4EE5\u4F7F\u66F4\u6539\u751F\u6548\u3002"
};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {};

// src/lang/helpers.ts
var localeMap = {
  ar: ar_default,
  cs: cz_default,
  da: da_default,
  de: de_default,
  en: en_default,
  "en-gb": en_gb_default,
  es: es_default,
  fr: fr_default,
  hi: hi_default,
  id: id_default,
  it: it_default,
  ja: ja_default,
  ko: ko_default,
  nl: nl_default,
  nn: no_default,
  pl: pl_default,
  pt: pt_default,
  "pt-br": pt_br_default,
  ro: ro_default,
  ru: ru_default,
  tr: tr_default,
  "zh-cn": zh_cn_default,
  "zh-tw": zh_tw_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function t(str) {
  return locale && locale[str] || en_default[str];
}

// src/modal.ts
var _ModalWindow = class extends import_obsidian2.Modal {
  constructor(plugin, link, file, fragment, width, height) {
    super(plugin.app);
    this.handledLeaves = [];
    this.observer = null;
    this.handleBackgroundClick = (event) => {
      if (event.target === event.currentTarget) {
        this.close();
      }
    };
    this.refreshMarkdownViews = async () => {
      const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!view)
        return;
      let scrollPosition;
      if (view.getMode() === "preview") {
        scrollPosition = view.previewMode.getScroll();
        setTimeout(() => {
          view.previewMode.rerender(true);
        }, 100);
      } else if (view.getMode() === "source") {
        const editView = view.currentMode;
        if (editView && typeof editView.getScroll === "function") {
          scrollPosition = editView.getScroll();
        } else if (view.editor) {
          scrollPosition = view.editor.getScrollInfo();
        }
        const editor = view.editor;
        const content = editor.getValue();
        const modifiedContent = content.replace(/!\[\[(.+?)\]\]/g, "[[$1]]");
        editor.setValue(modifiedContent);
        setTimeout(() => {
          const finalContent = editor.getValue().replace(/\[\[(.+?)\]\]/g, (match, p1) => {
            return content.includes(`![[${p1}]]`) ? `![[${p1}]]` : `[[${p1}]]`;
          });
          editor.setValue(finalContent);
          const cursor = editor.getCursor();
          editor.setCursor(cursor);
        }, 100);
      }
      setTimeout(() => {
        const editView = view.currentMode;
        editView.applyScroll(scrollPosition);
      }, 500);
    };
    this.handleInternalLinkClick = (event) => {
      var _a;
      let target = event.target;
      let linkText = this.getLinkFromTarget(target);
      if (linkText == null ? void 0 : linkText.startsWith("#")) {
        const currentFilePath = ((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) || "";
        linkText = currentFilePath + linkText;
      }
      const [path, fragment] = linkText.split(/[#]/);
      const abstractFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
      let file;
      if (abstractFile instanceof import_obsidian2.TFile) {
        file = abstractFile;
      } else {
        file = void 0;
      }
      if (!file && !this.isValidURL(linkText)) {
        return;
      }
      if (file) {
        const filePath = `${file.path}#${fragment}`;
        const modalContainer = this.containerEl.querySelector(".modal-opener-content");
        if (modalContainer) {
          modalContainer.setAttribute("data-src", filePath);
          this.updateFragmentLink = true;
        }
      }
    };
    this.plugin = plugin;
    this.link = link;
    this.file = file;
    this.fragment = fragment || "";
    this.width = width || `${this.plugin.settings.modalWidth}%`;
    this.height = height || `${this.plugin.settings.modalHeight}%`;
    this.scope = new import_obsidian2.Scope(this.app.scope);
    this.boundHandleActiveLeafChange = this.handleActiveLeafChange.bind(this);
    _ModalWindow.instances.push(this);
    _ModalWindow.activeInstance = this;
    ModalOpenerPlugin.activeModalWindow = this;
    const modalElement = this.containerEl.querySelector(".modal");
    if (modalElement) {
      modalElement.addClass("modal-opener");
    }
    const modalBgElement = this.containerEl.querySelector(".modal-bg");
    if (modalBgElement) {
      modalBgElement.addClass("modal-opener-bg");
    }
  }
  async onOpen() {
    if (!this.contentEl) {
      return;
    }
    this.containerEl.addEventListener("click", this.handleInternalLinkClick, true);
    const modalBgElement = this.containerEl.querySelector(".modal-bg.modal-opener-bg");
    if (modalBgElement) {
      if (this.plugin.settings.onlyCloseButton) {
        modalBgElement.classList.remove("closable");
      } else {
        modalBgElement.classList.add("closable");
        modalBgElement.addEventListener("click", this.handleBackgroundClick);
      }
    }
    const modal = this.containerEl.lastChild;
    if (modal) {
      modal.style.width = this.width;
      modal.style.height = this.height;
    }
    if (this.file) {
      this.displayFileContent(this.file, this.fragment);
    } else {
      if (!this.link.startsWith("http://") && !this.link.startsWith("https://")) {
        const httpsLink = `https://${this.link}`;
        if (await this.checkURLReachability(httpsLink)) {
          this.link = httpsLink;
        } else {
          this.link = `http://${this.link}`;
        }
      }
      this.displayLinkContent(this.link);
    }
    this.scope.register([], "Escape", (evt) => {
      evt.preventDefault();
      this.close();
    });
    setTimeout(() => {
      if (_ModalWindow.activeInstance === this) {
        this.app.workspace.on("active-leaf-change", this.boundHandleActiveLeafChange);
      }
    }, 100);
  }
  close() {
    super.close();
    this.containerEl.removeEventListener("click", this.handleInternalLinkClick, true);
    this.app.workspace.off("active-leaf-change", this.boundHandleActiveLeafChange);
    _ModalWindow.instances = _ModalWindow.instances.filter((instance) => instance !== this);
    if (_ModalWindow.activeInstance === this) {
      _ModalWindow.activeInstance = _ModalWindow.instances[_ModalWindow.instances.length - 1] || null;
    }
    if (ModalOpenerPlugin.activeModalWindow === this) {
      ModalOpenerPlugin.activeModalWindow = null;
    }
  }
  onClose() {
    const modalOpener = this.containerEl.querySelector(".modal-opener");
    if (modalOpener && this.plugin.settings.enableRefreshOnClose) {
      const workspaceLeafContent = modalOpener.querySelector(".workspace-leaf-content");
      if (workspaceLeafContent) {
        const dataType = workspaceLeafContent.getAttribute("data-type");
        if (dataType === "canvas" || dataType === "mindmapview") {
          setTimeout(() => {
            this.refreshMarkdownViews();
          }, this.plugin.settings.delayInMs);
        }
      }
    }
    const modalBgElement = this.containerEl.querySelector(".modal-bg.modal-opener-bg");
    if (modalBgElement) {
      modalBgElement.removeEventListener("click", this.handleBackgroundClick);
    }
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    if (this.associatedLeaf) {
      this.associatedLeaf.detach();
      this.associatedLeaf = void 0;
    }
    this.handledLeaves.forEach((leaf) => {
      if (leaf.view) {
        leaf.detach();
      }
    });
    this.handledLeaves = [];
    const { contentEl } = this;
    contentEl.empty();
    if (document.querySelectorAll(".modal-opener").length === 0) {
      setTimeout(() => {
        this.exitMultiCursorMode();
      }, 100);
    }
  }
  exitMultiCursorMode() {
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (activeView && activeView.editor) {
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      editor.setCursor(cursor);
    }
  }
  handleActiveLeafChange() {
    if (_ModalWindow.activeInstance !== this) {
      return;
    }
    const activeLeaf = this.app.workspace.getLeaf(false);
    this.associatedLeaf = activeLeaf;
    if (activeLeaf) {
      const modalElement = this.containerEl.querySelector(".modal-opener");
      if (!modalElement)
        return;
      const modalContainer = modalElement.querySelector(".modal-opener-content");
      if (modalContainer) {
        modalContainer.empty();
        modalContainer.appendChild(activeLeaf.view.containerEl);
        this.handledLeaves.push(activeLeaf);
        const wbViewContent = activeLeaf.view.containerEl.querySelector(".wb-view-content");
        const activeFile = this.app.workspace.getActiveFile();
        if (wbViewContent) {
          const webviewElement = wbViewContent.querySelector("webview");
          if (webviewElement) {
            const srcValue = webviewElement.getAttribute("src");
            if (srcValue) {
              modalContainer.setAttribute("data-src", srcValue);
            }
          }
        } else if (activeFile && !this.updateFragmentLink) {
          const filePath = activeFile.path;
          modalContainer.setAttribute("data-src", filePath);
        }
        this.focusOnModalContent();
        this.updateFragmentLink = false;
      }
    }
  }
  async displayFileContent(file, fragment) {
    if (!this.contentEl) {
      return;
    }
    this.contentEl.empty();
    const fileContainer = this.contentEl.createEl("div", "modal-opener-content");
    fileContainer.setAttribute("data-src", file.path + (fragment ? "#" + fragment : ""));
    const wrapperContainer = this.contentEl.createEl("div", "modal-content-wrapper");
    if (this.plugin.settings.showFloatingButton) {
      if (this.plugin.settings.viewOfDisplayButton == "both" || this.plugin.settings.viewOfDisplayButton == "file") {
        this.addOpenInNewLeafButton(wrapperContainer);
      }
    }
    let mode;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    switch (this.plugin.settings.fileOpenMode) {
      case "source":
        mode = "source";
        break;
      case "preview":
        mode = "preview";
        break;
      default:
        mode = (activeView == null ? void 0 : activeView.getMode()) === "source" ? "source" : "preview";
    }
    if (fragment) {
      const filePath = `${file.path}#${fragment}`;
      const newLeaf = this.app.workspace.getLeaf(true);
      this.handledLeaves.push(newLeaf);
      await newLeaf.openFile(file);
      if (this.plugin.settings.hideTabHeader) {
        newLeaf.tabHeaderEl.style.display = "none";
      }
      this.associatedLeaf = newLeaf;
      setTimeout(() => {
        this.app.workspace.openLinkText(filePath, file.path, false);
      }, 100);
      const view = newLeaf.view;
      if (view instanceof import_obsidian2.MarkdownView) {
        const currentState = view.getState();
        currentState.mode = mode;
        view.setState(currentState, { history: false });
        fileContainer.appendChild(view.containerEl);
      }
    } else {
      const leaf = this.app.workspace.getLeaf(true);
      await leaf.openFile(file, { state: { mode } });
      this.handledLeaves.push(leaf);
      if (this.plugin.settings.hideTabHeader) {
        leaf.tabHeaderEl.style.display = "none";
      }
      fileContainer.appendChild(leaf.view.containerEl);
      this.leaf = leaf;
      this.associatedLeaf = leaf;
    }
    this.setContainerHeight(fileContainer, false);
    const noteToolbarPlugin = this.getPlugin("note-toolbar");
    if (noteToolbarPlugin) {
      this.setupToolbarObserver();
    }
    this.setupDoubleClickHandler();
    this.contentEl.tabIndex = -1;
    this.contentEl.focus();
  }
  displayLinkContent(link) {
    if (!this.contentEl) {
      return;
    }
    this.contentEl.empty();
    const wrapperContainer = this.contentEl.createEl("div", "modal-content-wrapper");
    const linkContainer = this.contentEl.createEl("div", "modal-opener-content");
    linkContainer.setAttribute("data-src", this.link);
    if (this.plugin.settings.showFloatingButton) {
      if (this.plugin.settings.viewOfDisplayButton == "both" || this.plugin.settings.viewOfDisplayButton == "link") {
        wrapperContainer.appendChild(linkContainer);
        this.addFloatingButton(wrapperContainer);
      }
    }
    const surfPlugin = this.getPlugin("surfing");
    if (surfPlugin) {
      window.open(link);
      setTimeout(() => {
        const currentLeaf = this.app.workspace.getLeaf(false);
        this.handledLeaves.push(currentLeaf);
        if (this.plugin.settings.hideTabHeader) {
          currentLeaf.tabHeaderEl.style.display = "none";
        }
        linkContainer.appendChild(currentLeaf.view.containerEl);
        if (this.associatedLeaf) {
          this.associatedLeaf.detach();
          this.associatedLeaf = void 0;
        }
        this.associatedLeaf = currentLeaf;
        this.setContainerHeight(linkContainer, true);
      }, 150);
    } else {
      const frame = linkContainer.createEl("iframe", { cls: "modal-iframe" });
      frame.src = link;
    }
    this.setupDoubleClickHandler();
  }
  getLinkFromTarget(target) {
    var _a;
    return target.getAttribute("data-href") || target.getAttribute("href") || target.getAttribute("data-path") || ((_a = target.textContent) == null ? void 0 : _a.trim()) || "";
  }
  focusOnModalContent() {
    var _a;
    if (((_a = this.associatedLeaf) == null ? void 0 : _a.view) instanceof import_obsidian2.MarkdownView) {
      const editor = this.associatedLeaf.view.editor;
      editor.focus();
    } else {
      const modalContainer = this.containerEl.querySelector(".modal-opener-content");
      if (modalContainer instanceof HTMLElement) {
        modalContainer.focus();
      }
    }
  }
  openInNewTab() {
    const modalElement = this.containerEl.querySelector(".modal-opener");
    if (!modalElement)
      return;
    const modalContainer = modalElement.querySelector(".modal-opener-content");
    if (modalContainer) {
      const src = modalContainer.getAttribute("data-src") || "";
      if (this.isValidURL(src)) {
        this.openExternalLink(src);
      } else {
        const [filePath, fragment] = src.split("#");
        const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian2.TFile) {
          this.plugin.app.workspace.openLinkText(src, filePath, "tab");
        }
      }
      _ModalWindow.instances.forEach((instance) => {
        instance.close();
      });
    }
  }
  setupDoubleClickHandler() {
    this.modalEl = this.containerEl.querySelector(".modal-opener");
    if (this.modalEl) {
      this.modalEl.addEventListener("dblclick", (event) => {
        const target = event.target;
        if (!this.isClickableArea(target)) {
          return;
        }
        this.openInNewTab();
      });
    }
  }
  isClickableArea(element) {
    var _a;
    if (element === this.modalEl || element.parentElement === this.modalEl) {
      return true;
    }
    if ((_a = this.contentEl) == null ? void 0 : _a.contains(element)) {
      return false;
    }
    if (["P", "SPAN", "H1", "H2", "H3", "H4", "H5", "H6", "UL", "OL", "LI", "CODE", "IMG"].includes(element.tagName)) {
      return false;
    }
    const excludedContainers = [".mm-app-container", ".workspace-leaf-content", ".markdown-preview-view", ".cm-node-text"];
    for (const selector of excludedContainers) {
      if (element.closest(selector)) {
        return false;
      }
    }
    return true;
  }
  openExternalLink(link) {
    const surfPlugin = this.getPlugin("surfing");
    if (surfPlugin) {
      window.open(link);
    } else {
      const newLeaf = this.app.workspace.getLeaf(true);
      const container = newLeaf.view.containerEl;
      container.empty();
      const frame = container.createEl("iframe", { cls: "modal-iframe" });
      frame.src = link;
      this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
    }
  }
  setContainerHeight(container, isLinkView) {
    const baseHeight = parseInt(this.plugin.settings.modalHeight, 10);
    let heightAdjustment = 5;
    if (isLinkView) {
      if (!this.plugin.settings.showLinkViewHeader) {
        heightAdjustment = this.containerEl.querySelector(".wb-bookmark-bar") ? -1 : 2;
      }
    } else {
      if (!this.plugin.settings.showFileViewHeader) {
        const leafContent = this.containerEl.querySelector(".modal-opener-content .workspace-leaf-content");
        if (leafContent) {
          const dataType = leafContent.getAttribute("data-type");
          if (dataType == "canvas" || dataType == "excalidraw") {
            heightAdjustment = dataType === "canvas" ? 1 : dataType === "excalidraw" ? 2 : 1;
          } else {
            const editingPlugin = this.getPlugin("editing-toolbar");
            const toolbarPlugin = this.getPlugin("note-toolbar");
            if (editingPlugin || toolbarPlugin) {
              heightAdjustment = toolbarPlugin ? 5 : editingPlugin ? 2 : 1;
            }
          }
        }
      } else {
        const leafContent = this.containerEl.querySelector(".modal-opener-content .workspace-leaf-content");
        if (leafContent) {
          const dataType = leafContent.getAttribute("data-type");
          if (dataType == "canvas" || dataType == "excalidraw") {
            heightAdjustment = dataType === "canvas" ? 5 : dataType === "excalidraw" ? 5 : 2;
          } else {
            const editingPlugin = this.getPlugin("editing-toolbar");
            const toolbarPlugin = this.getPlugin("note-toolbar");
            if (editingPlugin || toolbarPlugin) {
              heightAdjustment = toolbarPlugin ? 5 : editingPlugin ? 5 : 4;
            }
          }
        }
      }
    }
    const adjustedModalHeight = `${baseHeight - heightAdjustment}vh`;
    container.style.setProperty("--adjusted-modal-height", adjustedModalHeight);
  }
  getPlugin(pluginId) {
    const app = this.plugin.app;
    return app.plugins.plugins[pluginId];
  }
  async checkURLReachability(url) {
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url,
        method: "HEAD",
        throw: false
        // 不抛出错误，而是返回响应
      });
      return response.status >= 200 && response.status < 300;
    } catch (error) {
      return false;
    }
  }
  isValidURL(url) {
    try {
      const parsedURL = new URL(url);
      if (parsedURL.protocol === "http:" || parsedURL.protocol === "https:") {
        const isLocalIP = /^(https?:\/\/)?(10\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.(1[6-9]|2\d|3[01])\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3})(:\d+)?(\/.*)?$/.test(url);
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  // 适配NoteToolBar
  setupToolbarObserver() {
    this.ensureSingleToolbar();
    this.observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          this.ensureSingleToolbar();
        }
      }
    });
    this.observer.observe(this.contentEl, { childList: true, subtree: true });
  }
  ensureSingleToolbar() {
    const toolbars = this.contentEl.querySelectorAll(".cg-note-toolbar-container");
    if (toolbars.length > 1) {
      for (let i = 1; i < toolbars.length; i++) {
        toolbars[i].remove();
      }
    }
  }
  // 添加悬浮按钮
  addOpenInNewLeafButton(container) {
    const buttonContainer = container.createEl("div", { cls: "floating-button-container" });
    const openButton = buttonContainer.createEl("button", { cls: "floating-button" });
    (0, import_obsidian2.setIcon)(openButton, "lucide-panel-top");
    openButton.setAttribute("title", t("Opens in new tab"));
    openButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openInNewTab();
    });
  }
  addFloatingButton(container) {
    const buttonContainer = container.createEl("div", { cls: "floating-menu-container" });
    const mainButton = buttonContainer.createEl("button", { cls: "floating-button main-button" });
    (0, import_obsidian2.setIcon)(mainButton, "lucide-more-vertical");
    mainButton.setAttribute("title", t("More options"));
    const menuItems = buttonContainer.createEl("div", { cls: "floating-menu-items" });
    const surfPlugin = this.getPlugin("surfing");
    if (surfPlugin) {
      this.createMenuItem(menuItems, "lucide-sun-moon", t("Switch dark mode"), () => this.toggleDarkMode());
    }
    this.createMenuItem(menuItems, "lucide-compass", t("Open in browser"), () => this.openInBrowser());
    this.createMenuItem(menuItems, "lucide-panel-top", t("Opens in new tab"), () => this.openInNewTab());
    this.createMenuItem(menuItems, "lucide-copy", t("Copy web link"), () => this.copyWebLink());
    let timeoutId = null;
    buttonContainer.addEventListener("mouseenter", () => {
      if (timeoutId)
        clearTimeout(timeoutId);
      menuItems.style.display = "flex";
    });
    buttonContainer.addEventListener("mouseleave", () => {
      timeoutId = setTimeout(() => {
        menuItems.style.display = "none";
      }, 300);
    });
    menuItems.addEventListener("mouseenter", () => {
      if (timeoutId)
        clearTimeout(timeoutId);
    });
    menuItems.addEventListener("mouseleave", () => {
      timeoutId = setTimeout(() => {
        menuItems.style.display = "none";
      }, 300);
    });
  }
  createMenuItem(container, icon, title, onClick) {
    const button = container.createEl("button", { cls: "floating-button menu-item" });
    (0, import_obsidian2.setIcon)(button, icon);
    button.setAttribute("title", title);
    button.addEventListener("click", (e) => {
      e.stopPropagation();
      onClick();
    });
    return button;
  }
  toggleDarkMode() {
    const surfPlugin = this.getPlugin("surfing");
    if (surfPlugin) {
      this.app.commands.executeCommandById("surfing:toggle-dark-mode");
    }
  }
  copyWebLink() {
    const modalElement = this.containerEl.querySelector(".modal-opener-content");
    if (!modalElement)
      return;
    const dataSrc = modalElement.getAttribute("data-src");
    if (dataSrc) {
      navigator.clipboard.writeText(dataSrc).then(() => new import_obsidian2.Notice(t("Copied to clipboard")));
    }
  }
  openInBrowser() {
    const modalElement = this.containerEl.querySelector(".modal-opener");
    if (!modalElement)
      return;
    const modalContainer = modalElement.querySelector(".modal-opener-content");
    if (modalContainer) {
      const src = modalContainer.getAttribute("data-src") || "";
      if (this.isValidURL(src)) {
        const surfPlugin = this.getPlugin("surfing");
        if (surfPlugin) {
          this.app.commands.executeCommandById("surfing:open-current-url-with-external-browser");
        } else {
          window.open(src);
        }
      }
    }
  }
};
var ModalWindow = _ModalWindow;
ModalWindow.instances = [];
ModalWindow.activeInstance = null;

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  openMethod: "both",
  fileOpenMode: "current",
  modalWidth: "86vw",
  modalHeight: "86vh",
  dragThreshold: 200,
  enableAnimation: true,
  onlyCloseButton: false,
  customCommands: [],
  showFileViewHeader: false,
  showLinkViewHeader: false,
  showMetadata: false,
  hideTabHeader: true,
  preventsDuplicateTabs: false,
  delayInMs: 100,
  enableRefreshOnClose: true,
  showFloatingButton: true,
  viewOfDisplayButton: "both"
};
var ModalOpenerSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.openMethod = this.plugin.settings.openMethod;
    this.fileOpenMode = this.plugin.settings.fileOpenMode;
    this.modalWidth = this.plugin.settings.modalWidth;
    this.modalHeight = this.plugin.settings.modalHeight;
    this.dragThreshold = this.plugin.settings.dragThreshold;
    this.enableAnimation = this.plugin.settings.enableAnimation;
    this.onlyCloseButton = this.plugin.settings.onlyCloseButton;
    this.customCommands = this.plugin.settings.customCommands;
    this.showFileViewHeader = this.plugin.settings.showFileViewHeader;
    this.showLinkViewHeader = this.plugin.settings.showLinkViewHeader;
    this.showFloatingButton = this.plugin.settings.showFloatingButton;
    this.viewOfDisplayButton = this.plugin.settings.viewOfDisplayButton;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName(t("Open with")).addDropdown((dd) => dd.addOption("both", t("Both")).addOption("drag", t("Drag & Drop")).addOption("altclick", t("Alt & Left click")).setValue(this.plugin.settings.openMethod).onChange(async (value) => {
      this.plugin.settings.openMethod = value;
      await this.plugin.saveSettings();
      await this.reloadPlugin();
      this.display();
    }));
    if (this.plugin.settings.openMethod === "drag" || this.plugin.settings.openMethod === "both") {
      new import_obsidian3.Setting(containerEl).setName(t("Drag and drop time threshold")).setDesc(t("Set the minimum drag and drop time (in milliseconds) to trigger the link to open.")).addText((text) => text.setValue(String(this.plugin.settings.dragThreshold)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue >= 0) {
          this.plugin.settings.dragThreshold = numValue;
          await this.plugin.saveSettings();
        }
      }));
    }
    new import_obsidian3.Setting(containerEl).setName(t("Default editing mode")).setDesc(t("Select the default mode for opening files in the modal window")).addDropdown((dropdown) => dropdown.addOption("current", t("Current file")).addOption("preview", t("Reading")).addOption("source", t("Editing")).setValue(this.plugin.settings.fileOpenMode).onChange(async (value) => {
      this.plugin.settings.fileOpenMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Add hover button")).setDesc(t("Add hover button for accessibility functions in the modal window")).addToggle((toggle) => toggle.setValue(this.plugin.settings.showFloatingButton).onChange(async (value) => {
      this.plugin.settings.showFloatingButton = value;
      await this.plugin.saveSettings();
      await this.reloadPlugin();
    }));
    if (this.plugin.settings.showFloatingButton) {
      new import_obsidian3.Setting(containerEl).setName(t("Add hover button to")).addDropdown((dropdown) => dropdown.addOption("both", t("Both")).addOption("file", t("File view")).addOption("link", t("Link view")).setValue(this.plugin.settings.viewOfDisplayButton).onChange(async (value) => {
        this.plugin.settings.viewOfDisplayButton = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian3.Setting(containerEl).setName(t("Behavior")).setHeading();
    new import_obsidian3.Setting(containerEl).setName(t("Disable external click close")).setDesc(t('Use only the "Close" button and "Esc" to close.')).addToggle((toggle) => toggle.setValue(this.plugin.settings.onlyCloseButton).onChange(async (value) => {
      this.plugin.settings.onlyCloseButton = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Refresh view on close")).setDesc(t("Refresh views when closing modal window, currently only refreshing after editing Canvas and Markmind file")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enableRefreshOnClose).onChange(async (value) => {
      this.plugin.settings.enableRefreshOnClose = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Prevents duplicate tabs")).setDesc(t("In a new leaf opened the note to prevent duplicate (compatible with Modal-Opener, function from Mononote plugin)")).addToggle((toggle) => toggle.setValue(this.plugin.settings.preventsDuplicateTabs).onChange(async (value) => {
      this.plugin.settings.preventsDuplicateTabs = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Delay time")).setDesc(t("Delay in milliseconds before performing operations")).addSlider((slider) => slider.setLimits(100, 500, 100).setValue(this.plugin.settings.delayInMs).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.delayInMs = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Styles")).setHeading();
    new import_obsidian3.Setting(containerEl).setName(t("Modal width")).setDesc(t("Enter any valid CSS unit")).addText((text) => text.setValue(this.modalWidth).onChange(async (value) => {
      this.plugin.settings.modalWidth = value;
      this.modalWidth = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Modal height")).setDesc(t("Enter any valid CSS unit")).addText((text) => text.setValue(this.modalHeight).onChange(async (value) => {
      this.plugin.settings.modalHeight = value;
      this.modalHeight = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Hide tab header")).setDesc(t("Hides the tab header associated with the modal window")).addToggle((toggle) => toggle.setValue(this.plugin.settings.hideTabHeader).onChange(async (value) => {
      this.plugin.settings.hideTabHeader = value;
      await this.plugin.saveSettings();
      this.plugin.applyStyles();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Enable animation and blur")).setDesc(t("Toggle to enable or disable animation and blur effects")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAnimation).onChange(async (value) => {
      this.plugin.settings.enableAnimation = value;
      await this.plugin.saveSettings();
      this.plugin.applyStyles();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Show metadata")).setDesc(t("Show file metadata in the modal window")).addToggle((toggle) => toggle.setValue(this.plugin.settings.showMetadata).onChange(async (value) => {
      this.plugin.settings.showMetadata = value;
      await this.plugin.saveSettings();
      this.plugin.applyStyles();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Show view header of the file")).setDesc(t("Show the view header of the file in the modal window")).addToggle((toggle) => toggle.setValue(this.plugin.settings.showFileViewHeader).onChange(async (value) => {
      this.plugin.settings.showFileViewHeader = value;
      await this.plugin.saveSettings();
      this.plugin.applyStyles();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Show view header of the link")).setDesc(t("Show the Surfing plugin's navigation bar and bookmarks bar")).addToggle((toggle) => toggle.setValue(this.plugin.settings.showLinkViewHeader).onChange(async (value) => {
      this.plugin.settings.showLinkViewHeader = value;
      await this.plugin.saveSettings();
      this.plugin.applyStyles();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Custom commands")).setHeading();
    new import_obsidian3.Setting(containerEl).setName(t("Add custom command")).setDesc(t("Add a new custom command")).addButton((button) => button.setButtonText(t("Add")).onClick(() => {
      this.addCustomCommand();
    }));
    const customCommandsContainer = containerEl.createDiv("custom-commands-container");
    this.plugin.settings.customCommands.forEach((command, index) => {
      this.createCustomCommandSetting(customCommandsContainer, command, index);
    });
  }
  addCustomCommand() {
    const newCommand = {
      id: "",
      name: "",
      command: ""
    };
    this.plugin.settings.customCommands.push(newCommand);
    this.display();
  }
  createCustomCommandSetting(containerEl, command, index) {
    let tempCommand = { ...command };
    const setting = new import_obsidian3.Setting(containerEl).addText((text) => text.setPlaceholder(t("Command name")).setValue(tempCommand.name).onChange((value) => {
      tempCommand.id = `modal-opener:${value}`;
      tempCommand.name = value;
    })).addText((text) => text.setPlaceholder(t("Description")).setValue(tempCommand.command).onChange((value) => {
      tempCommand.command = value;
    })).addButton((button) => button.setButtonText(t("Confirm")).onClick(async () => {
      if (tempCommand.name && tempCommand.command) {
        const isDuplicate = this.plugin.settings.customCommands.some(
          (cmd, i) => cmd.name === tempCommand.name && i !== index
        );
        if (isDuplicate) {
          new import_obsidian3.Notice(t("The command name already exists, please use a different name"));
          return;
        }
        if (index >= 0) {
          this.plugin.settings.customCommands[index] = tempCommand;
        } else {
          this.plugin.settings.customCommands.push(tempCommand);
        }
        await this.plugin.saveSettings();
        new import_obsidian3.Notice(t("Command added successfully"));
        this.display();
      } else {
        new import_obsidian3.Notice(t("Please enter both command name and description"));
      }
    })).addExtraButton((button) => button.setIcon("trash").setTooltip(t("Delete")).onClick(() => {
      this.deleteCustomCommand(index);
    }));
    const textInputs = setting.controlEl.querySelectorAll(".setting-item-control input");
    textInputs.forEach((input) => {
      input.addClass("custom-command-input");
    });
    return setting;
  }
  deleteCustomCommand(index) {
    this.plugin.settings.customCommands.splice(index, 1);
    this.plugin.saveSettings();
    this.reloadPlugin();
    this.display();
    new import_obsidian3.Notice(t("Command deleted successfully. Please restart Obsidian for changes to take full effect."));
  }
  async reloadPlugin() {
    await this.plugin.saveSettings();
    const app = this.plugin.app;
    await app.plugins.disablePlugin("modal-opener");
    await app.plugins.enablePlugin("modal-opener");
    app.setting.openTabById("modal-opener").display();
  }
};

// src/main.ts
var _ModalOpenerPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.draggedLink = null;
    this.dragStartTime = null;
    this.processors = /* @__PURE__ */ new Map();
    this.isValidURL = (url) => ["http://", "https://", "www.", "192.", "127."].some((prefix) => url.startsWith(prefix));
  }
  async onload() {
    await this.loadSettings();
    this.registerOpenHandler();
    this.registerContextMenuHandler();
    this.applyStyles();
    this.registerCustomCommands();
    this.addSettingTab(new ModalOpenerSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.registerEvent(
        this.app.workspace.on("active-leaf-change", this.onActiveLeafChange.bind(this))
      );
    });
    this.addCommand({
      id: "open-in-modal-window",
      name: "Open current tab content in modal",
      callback: () => this.openCurrentContentInModal()
    });
    this.addCommand({
      id: "duplicate-in-modal-window",
      name: "Duplicate current tab content in modal",
      callback: () => this.duplicateCurrentContentInModal()
    });
    this.addCommand({
      // This command binds the shortcut key in the bindHotkey() function of modal.ts and defines the functionality in the openInNewTab() function
      id: "open-modal-content-in-new-tab",
      name: "Open modal content in new tab",
      callback: () => {
        if (_ModalOpenerPlugin.activeModalWindow) {
          _ModalOpenerPlugin.activeModalWindow.openInNewTab();
        } else {
          new import_obsidian4.Notice(t("No active modal window"));
        }
      }
    });
  }
  applyStyles() {
    document.body.classList.toggle("modal-animation-enabled", this.settings.enableAnimation);
    document.body.classList.toggle("show-file-view-header", this.settings.showFileViewHeader);
    document.body.classList.toggle("show-link-view-header", this.settings.showLinkViewHeader);
    document.body.classList.toggle("show-metadata", this.settings.showMetadata);
  }
  onunload() {
    this.removeEventListeners();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.registerOpenHandler();
    this.registerCustomCommands();
  }
  openContentInModal(shouldDetach = false) {
    var _a;
    const currentFile = ((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) || "";
    const file = this.app.vault.getAbstractFileByPath(currentFile);
    const activeLeaf = this.app.workspace.getLeaf(false);
    if (!activeLeaf) {
      return;
    }
    const surfPlugin = this.app.plugins.plugins["surfing"];
    const frameSelector = surfPlugin ? ".wb-frame" : "iframe";
    const frameElement = activeLeaf.view.containerEl.querySelector(frameSelector);
    const linkValue = (frameElement == null ? void 0 : frameElement.src) || "";
    new ModalWindow(
      this,
      linkValue,
      file instanceof import_obsidian4.TFile ? file : void 0,
      "",
      this.settings.modalWidth,
      this.settings.modalHeight
    ).open();
    if (shouldDetach) {
      activeLeaf.detach();
    }
  }
  openCurrentContentInModal() {
    this.openContentInModal(true);
  }
  duplicateCurrentContentInModal() {
    this.openContentInModal(false);
  }
  registerCustomCommands() {
    this.settings.customCommands.forEach((command) => {
      this.addCommand({
        id: command.id,
        name: command.name,
        callback: () => this.executeCustomCommand(command.command)
      });
    });
  }
  executeCustomCommand(command) {
    if (this.isValidURL(command)) {
      this.openInFloatPreview(command);
    } else {
      if (command.includes(".canvas") || command.includes(".md") || command.includes(".excalidraw")) {
        this.openInFloatPreview(command);
      } else {
        new import_obsidian4.Notice(t("Unsupported file or link format"));
      }
    }
  }
  removeEventListeners() {
    if (this.dragHandler) {
      document.removeEventListener("dragstart", this.dragHandler);
      document.removeEventListener("dragend", this.dragHandler);
      this.dragHandler = void 0;
    }
    if (this.altClickHandler) {
      document.removeEventListener("click", this.altClickHandler, { capture: true });
      this.altClickHandler = void 0;
    }
  }
  registerOpenHandler() {
    this.removeEventListeners();
    if (this.settings.openMethod === "drag" || this.settings.openMethod === "both") {
      this.registerDragHandler();
    }
    if (this.settings.openMethod === "altclick" || this.settings.openMethod === "both") {
      this.registerAltClickHandler();
    }
  }
  registerDragHandler() {
    this.dragHandler = () => {
      this.registerDomEvent(document, "dragstart", (evt) => {
        const target = evt.target;
        if (this.isPreviewModeLink(target)) {
          if (!target.closest(".nav-folder-children") && !target.closest(".nav-folder")) {
            this.draggedLink = this.getPreviewModeLinkText(target);
            this.dragStartTime = Date.now();
          }
        }
      });
      this.registerDomEvent(document, "dragend", (_evt) => {
        if (this.draggedLink) {
          if (this.settings.dragThreshold === 0) {
            this.openInFloatPreview(this.draggedLink);
          } else if (this.dragStartTime) {
            const dragDuration = Date.now() - this.dragStartTime;
            if (dragDuration >= this.settings.dragThreshold) {
              this.openInFloatPreview(this.draggedLink);
            } else {
              new import_obsidian4.Notice(t("Drag duration too short"));
            }
          }
          this.draggedLink = null;
          this.dragStartTime = null;
        }
      });
    };
    this.dragHandler();
  }
  handlePreviewModeLink(evt) {
    let target = evt.target;
    if (target.classList.contains("canvas-minimap") || target.classList.contains("file-embed-title") || target.classList.contains("markdown-embed-link") || target.closest("svg")) {
      target = target.closest(".internal-embed") || target;
    }
    if (this.isPreviewModeLink(target)) {
      console.log("111111");
      evt.preventDefault();
      evt.stopImmediatePropagation();
      const link = this.getPreviewModeLinkText(target);
      const isFolderLink = target.classList.contains("has-folder-note");
      const app = this.app;
      const folderPlugin = app.plugins.plugins["folder-notes"];
      if (!folderPlugin || !isFolderLink) {
        this.openInFloatPreview(link);
      } else {
        this.folderNoteOpenInFloatPreview(link);
      }
    }
  }
  handleEditModeLink(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const linkMatch = this.findLinkAtPosition(line, cursor.ch);
    if (linkMatch) {
      this.openInFloatPreview(linkMatch);
    } else {
      new import_obsidian4.Notice(t("No link found at cursor position"));
    }
  }
  // private registerMouseMiddleClickHandler() {
  //     this.middleClickHandler = (evt: MouseEvent) => {
  //         if (evt.button === 1) {
  //             const target = evt.target as HTMLElement;
  //             // if (this.isPreviewModeLink(target) || this.isEditModeLink(target)) {
  //             if (this.isPreviewModeLink(target)) {
  //                 evt.preventDefault();
  //                 evt.stopPropagation();
  //                 this.handlePreviewModeLink(evt);
  //             }
  //         }
  //     };
  //     document.addEventListener('mousedown', this.middleClickHandler, { capture: true });
  // }
  // 等canvas alt+click和其他类型一样表现为选取链接 可以改用此方法
  // private registerAltClickHandler() {
  //     this.registerDomEvent(document, 'click', (evt: MouseEvent) => {
  //         if (evt.altKey && evt.button === 0) {
  //             // 使用 setTimeout 来确保我们的处理在默认操作之后执行
  //             setTimeout(() => {
  //                 const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
  //                 if (activeView) {
  //                     let targetElement = evt.target as HTMLElement;
  //                     let altText = targetElement.getAttribute("alt");
  //                     if (this.isPreviewModeLink(targetElement)) {
  //                         this.handlePreviewModeLink(evt);
  //                     } else {
  //                         if (activeView.getMode() === 'source') {
  //                             // 适配 markmind 在编辑模式下嵌入视图的 alt 点击
  //                             if (targetElement.closest('svg')) {
  //                                 this.handlePreviewModeLink(evt);
  //                                 return;
  //                             }
  //                             // 适配diagram.net svg 类型的文件 alt+点击  不做处理
  //                             if (altText && altText.endsWith(".svg")) {
  //                                 return;
  //                             }
  //                             this.handleEditModeLink(activeView.editor);
  //                         } else {
  //                             this.handlePreviewModeLink(evt);
  //                         }
  //                     }
  //                 }
  //             }, 10);
  //         }
  //     });
  // }
  isInFencedCodeBlock(editor, pos) {
    const currentLine = pos.line;
    let fenceCount = 0;
    for (let i = 0; i <= currentLine; i++) {
      const line = editor.getLine(i).trim();
      if (line.startsWith("```")) {
        fenceCount++;
      }
    }
    return fenceCount % 2 === 1;
  }
  registerAltClickHandler() {
    this.altClickHandler = (evt) => {
      var _a;
      if (evt.altKey && evt.ctrlKey && evt.button === 0) {
        return;
      }
      if (evt.altKey && evt.button === 0) {
        const activefileView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        if (!activefileView)
          return;
        const editor = activefileView.editor;
        const cursor = editor.getCursor();
        if (this.isInFencedCodeBlock(editor, cursor)) {
          this.app.commands.executeCommandById("vscode-editor:edit-fence");
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              console.log("Mutation:", mutation);
              mutation.addedNodes.forEach((node) => {
                console.log("Added node:", node);
                if (node instanceof HTMLElement) {
                  console.log("Node classes:", node.classList);
                  if (node.classList.contains("modal")) {
                    console.log("Found modal, adding classes");
                    node.classList.add("modal");
                    node.classList.add("modal-opener");
                    observer.disconnect();
                  }
                }
              });
            });
          });
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
          return;
        }
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        let targetElement = evt.target;
        let altText = targetElement.getAttribute("alt");
        console.log("Clicked element:", targetElement);
        console.log("Classes:", targetElement.classList);
        if (activeView) {
          if (this.isPreviewModeLink(targetElement)) {
            this.handlePreviewModeLink(evt);
          } else {
            if (activeView.getMode() === "source") {
              if (targetElement.closest("svg")) {
                this.handlePreviewModeLink(evt);
                return;
              }
              if (altText && altText.endsWith(".svg")) {
                return;
              }
              this.handleEditModeLink(activeView.editor);
              evt.preventDefault();
              evt.stopImmediatePropagation();
            } else {
              this.handlePreviewModeLink(evt);
            }
          }
        } else {
          const link = (_a = targetElement.textContent) == null ? void 0 : _a.trim().replace(/\[\[(.*?)\]\]/, "$1");
          if (link) {
            this.openInFloatPreview(link);
          }
        }
      }
    };
    document.addEventListener("click", this.altClickHandler, { capture: true });
  }
  registerContextMenuHandler() {
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        const folderTarget = this.getFolderElement(file.path);
        const app = this.app;
        const folderPlugin = app.plugins.plugins["folder-notes"];
        if (folderPlugin) {
          if (folderTarget && folderTarget.classList.contains("has-folder-note")) {
            this.addFolderFloatMenuItem(menu, file.path);
          } else if (!folderTarget) {
            this.addFileFloatMenuItem(menu, file.path);
          }
        } else {
          if (!folderTarget) {
            this.addFileFloatMenuItem(menu, file.path);
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("url-menu", (menu, link) => {
        this.addLinkFloatMenuItem(menu, link);
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        let parentPath = "";
        if (view.file && view.file.parent) {
          parentPath = view.file.parent.path;
        }
        this.addCreateFileMenuItem(menu, parentPath);
        this.addDeleteAttachmentMenuItem(menu, editor);
      })
    );
  }
  addFloatMenuItem(menu, link, title, onClick) {
    menu.addItem(
      (item) => item.setTitle(title).setIcon("popup-open").setSection("open").onClick(onClick)
    );
  }
  getFolderElement(filePath) {
    return document.querySelector(`.nav-folder-title[data-path="${filePath}"]`);
  }
  addFileFloatMenuItem(menu, link) {
    this.addFloatMenuItem(menu, link || "", t("Open in modal window"), () => {
      var _a;
      if (link) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        if (activeView && activeView.getMode() === "source") {
          const editor = activeView.editor;
          const cursor = editor.getCursor();
          const line = editor.getLine(cursor.line);
          const foundLink = this.findLinkAtPosition(line, cursor.ch);
          if (foundLink) {
            this.openInFloatPreview(foundLink);
          } else {
            this.openInFloatPreview(link);
          }
        } else if (activeView && activeView.getMode() === "preview") {
          const selection = window.getSelection();
          if (selection && selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const linkElement = (_a = range.startContainer.parentElement) == null ? void 0 : _a.closest("a");
            if (linkElement) {
              link = linkElement.getAttribute("data-href") || linkElement.getAttribute("href") || link;
              this.openInFloatPreview(link);
            }
          } else {
            this.openInFloatPreview(link);
          }
        } else {
          this.openInFloatPreview(link);
        }
      }
    });
  }
  addFolderFloatMenuItem(menu, link) {
    this.addFloatMenuItem(menu, link || "", t("Open in modal window"), () => {
      if (link) {
        this.folderNoteOpenInFloatPreview(link);
      }
    });
  }
  addLinkFloatMenuItem(menu, link) {
    this.addFloatMenuItem(menu, link || "", t("Open in modal window"), () => {
      if (link) {
        this.openInFloatPreview(link);
      }
    });
  }
  async openInFloatPreview(link) {
    var _a;
    try {
      if (link == null ? void 0 : link.startsWith("#")) {
        const currentFilePath = ((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) || "";
        link = currentFilePath + link;
      }
      const [linkWithoutAlias] = link.split("|");
      const [filePath, fragment] = linkWithoutAlias.split("#");
      const abstractFile = this.app.metadataCache.getFirstLinkpathDest(filePath, "");
      let file;
      if (abstractFile instanceof import_obsidian4.TFile) {
        file = abstractFile;
      } else {
        file = void 0;
      }
      if (!file && !this.isValidURL(link)) {
        new import_obsidian4.Notice(t("The file or link does not exist: ") + filePath);
        return;
      }
      new ModalWindow(
        this,
        this.isValidURL(link) ? link : "",
        file,
        fragment != null ? fragment : "",
        this.settings.modalWidth,
        this.settings.modalHeight
      ).open();
    } catch (error) {
      new import_obsidian4.Notice(t("Open in modal window error"));
    }
  }
  async folderNoteOpenInFloatPreview(link) {
    try {
      let file;
      const fileNameOnly = link.split(/[/\\]/).pop() || link;
      let abstractFile = this.app.vault.getAbstractFileByPath(`${link}/${fileNameOnly}.md`);
      if (abstractFile instanceof import_obsidian4.TFile) {
        file = abstractFile;
      } else {
        abstractFile = this.app.vault.getAbstractFileByPath(`${link}/${fileNameOnly}.canvas`);
        if (abstractFile instanceof import_obsidian4.TFile) {
          file = abstractFile;
        } else {
          const possibleFile = this.app.metadataCache.getFirstLinkpathDest(fileNameOnly, "");
          if (possibleFile instanceof import_obsidian4.TFile) {
            file = possibleFile;
          }
        }
      }
      new ModalWindow(
        this,
        "",
        file,
        "",
        this.settings.modalWidth,
        this.settings.modalHeight
      ).open();
    } catch (error) {
      new import_obsidian4.Notice(t("Open in modal window error"));
    }
  }
  // create File And Open In Modal
  addCreateFileMenuItem(menu, parentPath) {
    menu.addItem((item) => {
      item.setTitle(t("Create and edit in modal")).setIcon("file-plus");
      const subMenu = item.setSubmenu();
      subMenu.addItem(
        (subItem) => subItem.setTitle("Markdown").setIcon("file").onClick(() => {
          this.createFileAndEditInModal(parentPath, "md");
        })
      );
      const canvasPlugin = this.app.internalPlugins.getEnabledPluginById("canvas");
      if (canvasPlugin) {
        subMenu.addItem(
          (subItem) => subItem.setTitle("Canvas").setIcon("layout-dashboard").onClick(() => {
            this.createFileAndEditInModal(parentPath, "canvas");
          })
        );
      }
      const excalidrawPlugin = this.getPlugin("obsidian-excalidraw-plugin");
      const excalidrawymjrPlugin = this.getPlugin("obsidian-excalidraw-plugin-ymjr");
      if (excalidrawPlugin || excalidrawymjrPlugin) {
        subMenu.addSeparator();
        subMenu.addItem(
          (subItem) => subItem.setTitle("Excalidraw").setIcon("swords").onClick(async () => {
            const initialLeafCount = this.app.workspace.getLeavesOfType("excalidraw").length;
            let commandId;
            if (excalidrawPlugin) {
              commandId = "obsidian-excalidraw-plugin:excalidraw-autocreate-and-embed-new-tab";
            } else if (excalidrawymjrPlugin) {
              commandId = "obsidian-excalidraw-plugin-ymjr:excalidraw-autocreate-and-embed-new-tab";
            }
            this.app.commands.executeCommandById(commandId);
            const waitForNewLeaf = () => {
              return new Promise((resolve) => {
                const checkLeaf = () => {
                  const currentLeafCount = this.app.workspace.getLeavesOfType("excalidraw").length;
                  if (currentLeafCount > initialLeafCount) {
                    resolve();
                  } else {
                    setTimeout(checkLeaf, 50);
                  }
                };
                checkLeaf();
              });
            };
            await waitForNewLeaf();
            setTimeout(() => {
              this.openCurrentContentInModal();
            }, 150);
          })
        );
      }
      const diagramsPlugin = this.getPlugin("obsidian-diagrams-net");
      if (diagramsPlugin) {
        subMenu.addItem(
          (subItem) => subItem.setTitle("Diagrams").setIcon("pencil-ruler").onClick(() => {
            this.app.commands.executeCommandById("obsidian-diagrams-net:app:diagrams-net-new-diagram");
          })
        );
      }
      subMenu.addSeparator();
      const excelPlugin = this.getPlugin("excel");
      if (excelPlugin) {
        subMenu.addItem(
          (subItem) => subItem.setTitle("Excel").setIcon("table").onClick(async () => {
            await this.createFileAndInsertLink("excel:excel-autocreate", true);
          })
        );
      }
      const SheetPlugin = this.getPlugin("sheet-plus");
      if (SheetPlugin) {
        subMenu.addItem(
          (subItem) => subItem.setTitle("Sheet Plus").setIcon("grid").onClick(async () => {
            await this.createFileAndInsertLink("sheet-plus:spreadsheet-autocreation", true);
          })
        );
      }
      const vscodePlugin = this.getPlugin("vscode-editor");
      if (vscodePlugin) {
        subMenu.addItem(
          (subItem) => subItem.setTitle("Code File").setIcon("file-code").onClick(async () => {
            await this.createCodeFileAndOpenInModal();
          })
        );
      }
      const markmindPlugin = this.getPlugin("obsidian-markmind");
      if (markmindPlugin) {
        subMenu.addItem(
          (subItem) => subItem.setTitle("MarkMind").setIcon("brain-circuit").onClick(async () => {
            await this.createFileAndInsertLink("obsidian-markmind:Create New MindMap", true);
          })
        );
      }
    });
  }
  addDeleteAttachmentMenuItem(menu, editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const linkMatch = this.findLinkAtPosition(line, cursor.ch);
    if (linkMatch) {
      const [filePath] = linkMatch.split("|");
      const [filePathWithoutAnchor] = filePath.split("#");
      const file = this.app.metadataCache.getFirstLinkpathDest(filePathWithoutAnchor, "");
      if (file && file instanceof import_obsidian4.TFile) {
        menu.addItem((item) => {
          item.setTitle(t("Delete linked attachment")).setIcon("trash").onClick(() => {
            const modal = new import_obsidian4.Modal(this.app);
            modal.titleEl.setText(t("Confirm deletion"));
            const content = modal.contentEl.createDiv();
            content.setText(t("Are you sure you want to delete: ") + file.path);
            const buttonContainer = content.createDiv({ cls: "modal-button-container" });
            buttonContainer.createEl("button", { text: t("Cancel") }).onclick = () => modal.close();
            buttonContainer.createEl(
              "button",
              { text: t("Delete"), cls: "mod-warning" }
            ).onclick = async () => {
              try {
                await this.app.fileManager.trashFile(file);
                const startIndex = line.indexOf("![[");
                const isEmbed = startIndex !== -1;
                const from = {
                  line: cursor.line,
                  ch: isEmbed ? startIndex : line.indexOf("[[")
                };
                const to = {
                  line: cursor.line,
                  ch: line.indexOf("]]") + 2
                };
                editor.replaceRange("", from, to);
                new import_obsidian4.Notice(t("File moved to trash"));
                modal.close();
              } catch (error) {
                new import_obsidian4.Notice(t("Failed to delete file"));
              }
            };
            modal.open();
          });
        });
      }
    }
  }
  async createFileAndInsertLink(commandId, isEmbed) {
    const previousView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    let previousEditor = null;
    let previousCursor = null;
    if (previousView) {
      previousEditor = previousView.editor;
      previousCursor = previousEditor.getCursor();
    }
    this.app.commands.executeCommandById(commandId);
    const newLeaf = this.app.workspace.getLeaf(true);
    this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
    const activeFile = await this.waitForActiveFile();
    if (activeFile && previousEditor && previousCursor) {
      const fileName = activeFile.name;
      const filePath = activeFile.path;
      const linkText = isEmbed ? `![[${filePath}|${fileName}]]` : `[[${filePath}|${fileName}]]`;
      if (previousView) {
        this.app.workspace.setActiveLeaf(previousView.leaf, { focus: true });
        previousEditor == null ? void 0 : previousEditor.replaceRange(linkText, previousCursor);
      }
      const newCursor = {
        line: previousCursor.line,
        ch: previousCursor.ch + linkText.length
      };
      previousEditor.setCursor(newCursor);
      this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
    }
    this.openCurrentContentInModal();
  }
  async waitForActiveFile(timeout = 5e3) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        return activeFile;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    return null;
  }
  async createCodeFileAndOpenInModal() {
    return new Promise((resolve) => {
      let fileName = "";
      let fileExtension = "";
      const observer = new MutationObserver((mutations, obs) => {
        for (const mutation of mutations) {
          for (const node of Array.from(mutation.addedNodes)) {
            if (node instanceof HTMLElement) {
              if (node.classList.contains("modal-container")) {
                const confirmButton = node.querySelector(".mod-cta");
                const inputElement = node.querySelector("input");
                let selectElement = node.querySelector(".modal_select");
                const codePlugin = this.getPlugin("code-files");
                if (codePlugin) {
                  selectElement = node.querySelector(".dropdown");
                }
                if (confirmButton && inputElement && selectElement) {
                  inputElement.addEventListener("input", () => {
                    fileName = inputElement.value || "";
                  });
                  inputElement.addEventListener("keyup", () => {
                    fileName = inputElement.value || "";
                  });
                  selectElement.addEventListener("change", () => {
                    fileExtension = selectElement.value;
                  });
                  confirmButton.addEventListener("click", async () => {
                    fileName = inputElement.value || fileName;
                    fileExtension = selectElement.value || fileExtension;
                    const fullFileName = `${fileName}.${fileExtension}|${fileName}`;
                    if (fileName != "") {
                      this.insertCodeFileLink(fullFileName, "");
                      setTimeout(() => {
                        this.openCurrentContentInModal();
                      }, 150);
                    }
                    obs.disconnect();
                    resolve();
                  });
                }
                return;
              }
            }
          }
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });
      setTimeout(() => {
        this.app.commands.executeCommandById("vscode-editor:create");
      }, 0);
      setTimeout(() => {
        observer.disconnect();
        resolve();
      }, 1e4);
    });
  }
  async getNewFileName(fileType) {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    const selectedText = ((_a = activeView == null ? void 0 : activeView.editor) == null ? void 0 : _a.getSelection()) || "";
    return new Promise((resolve) => {
      const modal = new import_obsidian4.Modal(this.app);
      modal.titleEl.setText(t("Enter new file name"));
      const container = modal.contentEl.createDiv({ cls: "new-file-modal-container" });
      const inputContainer = container.createDiv({ cls: "new-file-input-container" });
      const input = inputContainer.createEl("input", {
        type: "text",
        value: selectedText,
        placeholder: "File name",
        cls: "new-file-input"
      });
      input.focus();
      input.select();
      const select = inputContainer.createEl("select", { cls: "new-file-select" });
      if (fileType == "canvas") {
        select.createEl("option", { text: t("Embed link"), value: "embed" });
        select.createEl("option", { text: t("Wiki link"), value: "wikilink" });
      } else {
        select.createEl("option", { text: t("Wiki link"), value: "wikilink" });
        select.createEl("option", { text: t("Embed link"), value: "embed" });
      }
      const buttonContainer = container.createDiv({ cls: "new-file-button-container" });
      const confirmButton = buttonContainer.createEl("button", {
        text: t("Confirm"),
        cls: "new-file-button confirm"
      });
      const cancelButton = buttonContainer.createEl("button", {
        text: t("Cancel"),
        cls: "new-file-button cancel"
      });
      const confirmAction = () => {
        const fileName = input.value.trim();
        if (fileName) {
          resolve({
            fileName,
            isEmbed: select.value === "embed"
          });
          modal.close();
        }
      };
      confirmButton.onclick = confirmAction;
      input.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          confirmAction();
        }
      });
      cancelButton.onclick = () => {
        resolve(null);
        modal.close();
      };
      modal.open();
    });
  }
  insertCodeFileLink(filePath, content) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      const linkText = `![[${filePath}]]`;
      editor.replaceRange(linkText, cursor);
    }
  }
  insertLinkToActiveFile(filePath, displayName, isEmbed) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const selection = editor.getSelection();
      const linkText = isEmbed ? `![[${filePath}|${displayName}]]` : `[[${filePath}|${displayName}]]`;
      if (selection) {
        const from = editor.getCursor("from");
        const to = editor.getCursor("to");
        editor.replaceRange(linkText, from, to);
      } else {
        const cursor = editor.getCursor();
        editor.replaceRange(linkText, cursor);
      }
    }
  }
  async createFileAndEditInModal(parentPath, fileType) {
    const result = await this.getNewFileName(fileType);
    if (!result)
      return;
    const { fileName, isEmbed } = result;
    let newFilePath = "";
    if (fileName.includes("/") || parentPath === "/") {
      newFilePath = fileName;
    } else {
      newFilePath = `${parentPath}/${fileName}`;
    }
    if (!newFilePath.endsWith(`.${fileType}`)) {
      newFilePath += `.${fileType}`;
    }
    try {
      const newFile = await this.app.vault.create(newFilePath, "");
      new ModalWindow(
        this,
        "",
        newFile,
        "",
        this.settings.modalWidth,
        this.settings.modalHeight
      ).open();
      const displayName = newFile.basename;
      this.insertLinkToActiveFile(newFilePath, displayName, isEmbed);
    } catch (error) {
      new import_obsidian4.Notice(t("Failed to create file: ") + error.message);
    }
  }
  // no dupe leaf
  async onActiveLeafChange(activeLeaf) {
    if (!this.settings.preventsDuplicateTabs || activeLeaf.view.containerEl.closest(".modal-opener")) {
      return;
    }
    const { id } = activeLeaf;
    if (this.processors.has(id)) {
      return;
    }
    const processor = this.processActiveLeaf(activeLeaf);
    this.processors.set(id, processor);
    try {
      await processor;
    } finally {
      this.processors.delete(id);
    }
  }
  async processActiveLeaf(activeLeaf) {
    if (!this.settings.preventsDuplicateTabs) {
      return;
    }
    await new Promise((resolve) => setTimeout(resolve, this.settings.delayInMs));
    const filePath = activeLeaf.view.getState().file;
    if (!filePath)
      return;
    const viewType = activeLeaf.view.getViewType();
    const duplicateLeaves = this.app.workspace.getLeavesOfType(viewType).filter(
      (l) => l !== activeLeaf && l.view.getState().file === filePath && l.parent.id === activeLeaf.parent.id
    );
    if (duplicateLeaves.length === 0)
      return;
    const sortedLeaves = [activeLeaf, ...duplicateLeaves].sort(
      (a, b) => b.activeTime - a.activeTime
    );
    const mostRecentLeaf = sortedLeaves[0];
    const oldestLeaf = sortedLeaves[sortedLeaves.length - 1];
    if (activeLeaf !== mostRecentLeaf) {
      if (activeLeaf === oldestLeaf) {
        for (const leaf of duplicateLeaves) {
          if (!leaf.pinned) {
            leaf.detach();
          }
        }
        this.app.workspace.setActiveLeaf(activeLeaf, { focus: true });
      } else {
        if (activeLeaf.view.navigation && activeLeaf.history.backHistory.length > 0) {
          activeLeaf.history.back();
        } else if (!activeLeaf.pinned) {
          activeLeaf.detach();
        }
        this.app.workspace.setActiveLeaf(mostRecentLeaf, { focus: true });
      }
    } else {
      for (const leaf of duplicateLeaves) {
        if (!leaf.pinned) {
          leaf.detach();
        }
      }
    }
  }
  isPreviewModeLink(target) {
    return target.tagName === "A" && (target.classList.contains("external-link") || target.classList.contains("internal-link")) || target.classList.contains("auto-card-link-card") || target.classList.contains("recent-files-title-content") || target.classList.contains("metadata-link-inner") || target.classList.contains("has-folder-note") || target.classList.contains("homepage-button") || target.classList.contains("view-header-breadcrumb") || target.classList.contains("internal-embed") || target.classList.contains("file-embed-title") || target.classList.contains("embed-title") || target.classList.contains("markdown-embed-link") || target.classList.contains("markdown-embed-content") || target.classList.contains("canvas-minimap") || Array.from(target.classList).some((cls) => cls.startsWith("excalidraw-svg")) || target.classList.contains("svg");
  }
  getPreviewModeLinkText(target) {
    var _a;
    return target.getAttribute("data-href") || target.getAttribute("href") || target.getAttribute("data-path") || target.getAttribute("filesource") || target.getAttribute("src") || ((_a = target.textContent) == null ? void 0 : _a.trim()) || "";
  }
  findLinkAtPosition(line, position) {
    const linkRegex = /!?\[\[([^\]]+)\]\]|\[([^\]]+)\]\(([^)]+)\)|(https?:\/\/[^\s]+)/g;
    let match;
    while ((match = linkRegex.exec(line)) !== null) {
      if (match.index <= position && position <= match.index + match[0].length) {
        return match[1] || match[3] || match[4] || null;
      }
    }
    return null;
  }
  getPlugin(pluginId) {
    const app = this.app;
    return app.plugins.plugins[pluginId];
  }
};
var ModalOpenerPlugin = _ModalOpenerPlugin;
ModalOpenerPlugin.activeModalWindow = null;

/* nosourcemap */